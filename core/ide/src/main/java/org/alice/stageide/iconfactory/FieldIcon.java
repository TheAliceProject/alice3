/*******************************************************************************
 * Copyright (c) 2006, 2015, Carnegie Mellon University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Products derived from the software may not be called "Alice", nor may
 *    "Alice" appear in their name, without prior written permission of
 *    Carnegie Mellon University.
 *
 * 4. All advertising materials mentioning features or use of this software must
 *    display the following acknowledgement: "This product includes software
 *    developed by Carnegie Mellon University"
 *
 * 5. The gallery of art assets and animations provided with this software is
 *    contributed by Electronic Arts Inc. and may be used for personal,
 *    non-commercial, and academic use only. Redistributions of any program
 *    source code that utilizes The Sims 2 Assets must also retain the copyright
 *    notice, list of conditions and the disclaimer contained in
 *    The Alice 3.0 Art Gallery License.
 *
 * DISCLAIMER:
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
 * ANY AND ALL EXPRESS, STATUTORY OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A
 * PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHORS, COPYRIGHT OWNERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, PUNITIVE OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING FROM OR OTHERWISE RELATING TO
 * THE USE OF OR OTHER DEALINGS WITH THE SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
package org.alice.stageide.iconfactory;

import com.jogamp.opengl.GL;
import com.jogamp.opengl.GL2;
import com.jogamp.opengl.fixedfunc.GLMatrixFunc;
import com.jogamp.opengl.glu.GLU;
import edu.cmu.cs.dennisc.color.Color4f;
import edu.cmu.cs.dennisc.java.awt.GraphicsUtilities;
import edu.cmu.cs.dennisc.javax.swing.AsynchronousIcon;
import edu.cmu.cs.dennisc.math.AffineMatrix4x4;
import edu.cmu.cs.dennisc.math.Angle;
import edu.cmu.cs.dennisc.math.AngleInRadians;
import edu.cmu.cs.dennisc.math.AxisAlignedBox;
import edu.cmu.cs.dennisc.math.Point3;
import edu.cmu.cs.dennisc.math.Vector3;
import edu.cmu.cs.dennisc.render.ImageBuffer;
import edu.cmu.cs.dennisc.render.ImageCaptureObserver;
import edu.cmu.cs.dennisc.render.ImageOrientationRequirement;
import edu.cmu.cs.dennisc.render.OnscreenRenderTarget;
import edu.cmu.cs.dennisc.render.RenderTask;
import edu.cmu.cs.dennisc.render.RenderUtils;
import edu.cmu.cs.dennisc.render.gl.imp.GlrRenderContext;
import edu.cmu.cs.dennisc.render.gl.imp.RenderContext;
import edu.cmu.cs.dennisc.render.gl.imp.adapters.AdapterFactory;
import edu.cmu.cs.dennisc.render.gl.imp.adapters.GlrAbstractTransformable;
import edu.cmu.cs.dennisc.render.gl.imp.adapters.GlrScene;
import edu.cmu.cs.dennisc.scenegraph.AbstractCamera;
import edu.cmu.cs.dennisc.scenegraph.AbstractTransformable;
import edu.cmu.cs.dennisc.scenegraph.Component;
import edu.cmu.cs.dennisc.scenegraph.Scene;
import edu.cmu.cs.dennisc.scenegraph.Visual;
import edu.cmu.cs.dennisc.scenegraph.util.GoodLookAtUtils;
import org.alice.stageide.StageIDE;
import org.alice.stageide.sceneeditor.StorytellingSceneEditor;
import org.lgna.croquet.icon.TrimmedIcon;
import org.lgna.project.ast.UserField;
import org.lgna.story.implementation.AbstractTransformableImp;
import org.lgna.story.implementation.SceneImp;
import org.lgna.story.implementation.SingleVisualModelImp;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;

/**
 * @author Dennis Cosgrove
 */
public class FieldIcon extends AsynchronousIcon {

  //Use this variable to turn on/off the rendering off icons
  //When on icons will be generated by rendering the model. This is done to capture instance specific changes like color and size
  //When off icons will use the prerendered icons found in the gallery browser.
  private static final boolean USE_DYNAMICALLY_RENDERED_ICONS = false;

  public FieldIcon(UserField field, Icon fallbackIcon) {
    this.field = field;
    this.fallbackIcon = fallbackIcon;
  }

  public void markDirty() {
    this.imageIcon = null;
    this.isStarted = false;
  }

  @Override
  protected int getIconWidthFallback() {
    return this.fallbackIcon.getIconWidth();
  }

  @Override
  protected int getIconHeightFallback() {
    return this.fallbackIcon.getIconHeight();
  }

  @Override
  protected void paintIconFallback(java.awt.Component c, Graphics g, int x, int y) {
    this.fallbackIcon.paintIcon(c, g, x, y);
  }

  @Override
  protected synchronized Icon getResult(boolean isPaint) {
    if (this.imageIcon == null) {
      if (!USE_DYNAMICALLY_RENDERED_ICONS) {
        BufferedImage newIconImage = new BufferedImage(this.getIconWidthFallback(), this.getIconHeightFallback(), BufferedImage.TYPE_4BYTE_ABGR);
        Icon iconForImage = this.fallbackIcon;
        if (this.fallbackIcon instanceof TrimmedIcon) {
          iconForImage = ((TrimmedIcon) this.fallbackIcon).getImageIcon();
        }
        Image iconImage = GraphicsUtilities.getImageForIcon(iconForImage);
        GraphicsUtilities.drawCenteredScaledToFitImage(iconImage, newIconImage);
        this.imageIcon = new ImageIcon(newIconImage);
      } else {
        if (this.isStarted) {
          //pass
        } else {
          this.isStarted = true;

          Rectangle viewport = new Rectangle(0, 0, this.getIconWidth(), this.getIconHeight());

          Color4f backgroundColor = true ? null : Color4f.WHITE;
          final ImageBuffer rImageBuffer = RenderUtils.getDefaultRenderFactory().createImageBuffer(backgroundColor);
          StorytellingSceneEditor sceneEditor = StageIDE.getActiveInstance().getSceneEditor();

          AbstractTransformableImp fieldImp = sceneEditor.getImplementation(field);

          final AbstractTransformable sgTransformable = fieldImp.getSgComposite();
          final AffineMatrix4x4 absoluteTransform = sgTransformable.getAbsoluteTransformation();
          final AxisAlignedBox bbox = fieldImp.getAxisAlignedMinimumBoundingBox();
          Point3 center = bbox.getCenter();
          absoluteTransform.transform(center);
          final Point3 p = center;

          SceneImp sceneImp = sceneEditor.getActiveSceneImplementation();
          final Scene sgScene = sceneImp.getSgComposite();

          final Visual sgVisual;
          if (fieldImp instanceof SingleVisualModelImp) {
            SingleVisualModelImp singleVisualModelImp = (SingleVisualModelImp) fieldImp;
            sgVisual = singleVisualModelImp.getSgVisuals()[0];
          } else {
            Visual sgFoundVisual = null;
            for (Component sgComponent : sgTransformable.getComponents()) {
              if (sgComponent instanceof Visual) {
                sgFoundVisual = (Visual) sgComponent;
                break;
              }
            }
            sgVisual = sgFoundVisual;
          }

          OnscreenRenderTarget renderTarget = sceneEditor.getOnscreenRenderTarget();

          final AbstractCamera sgCamera = renderTarget.getSgCameraAt(0);
          renderTarget.getAsynchronousImageCapturer().captureImageBuffer(new RenderTask() {
            @Override
            public void render(Object context) {
              GlrRenderContext glrRenderContext = (GlrRenderContext) context;
              GL2 gl = glrRenderContext.getDrawable().getGL().getGL2();
              Rectangle viewport = glrRenderContext.getViewport();
              Color4f backgroundColor = rImageBuffer.getBackgroundColor();
              final boolean IS_ALPHA = backgroundColor == null;
              int clearMask;
              if (IS_ALPHA) {
                clearMask = GL.GL_DEPTH_BUFFER_BIT;
              } else {
                gl.glClearColor(backgroundColor.red, backgroundColor.green, backgroundColor.blue, backgroundColor.alpha);
                clearMask = GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT;
              }
              gl.glEnable(GL.GL_SCISSOR_TEST);
              gl.glScissor(viewport.x, viewport.y, viewport.width, viewport.height);
              gl.glClear(clearMask);
              gl.glDisable(GL.GL_SCISSOR_TEST);

              gl.glViewport(viewport.x, viewport.y, viewport.width, viewport.height);

              GLU glu = new GLU();
              gl.glMatrixMode(GLMatrixFunc.GL_PROJECTION);
              gl.glLoadIdentity();

              Angle verticalViewingAngle = new AngleInRadians(0.5);
              double aspectRatio = viewport.width / (double) viewport.height;
              glu.gluPerspective(verticalViewingAngle.getAsDegrees(), aspectRatio, 0.1, 100.0);

              GlrAbstractTransformable<?> transformableAdapter = AdapterFactory.getAdapterFor(sgTransformable);
              RenderContext rc = new RenderContext();
              rc.setGL(gl);
              rc.initialize();

              gl.glMatrixMode(GLMatrixFunc.GL_MODELVIEW);

              double distance;
              if (sgVisual != null) {
                distance = GoodLookAtUtils.calculateGoodLookAtDistance(sgVisual, verticalViewingAngle, aspectRatio, sgCamera);
              } else {
                distance = GoodLookAtUtils.calculateGoodLookAtDistance(bbox, absoluteTransform, verticalViewingAngle, aspectRatio, sgCamera);
              }
              //m = null;
              if (Double.isNaN(distance) == false) {
                //                  double[] array = new double[ 16 ];
                //                  java.nio.DoubleBuffer buffer = java.nio.DoubleBuffer.wrap( array );
                //                  m.getAsColumnMajorArray16( array );
                //                  gl.glLoadMatrixd( buffer );

                AffineMatrix4x4 cameraAbsolute = sgCamera.getAbsoluteTransformation();

                Vector3 v = Vector3.createSubtraction(cameraAbsolute.translation, p);
                v.normalize();
                v.multiply(distance);
                v.add(p);

                gl.glLoadIdentity();
                glu.gluLookAt(v.x, v.y, v.z, p.x, p.y, p.z, cameraAbsolute.orientation.up.x, cameraAbsolute.orientation.up.y, cameraAbsolute.orientation.up.z);
              } else {
                gl.glLoadIdentity();
                glu.gluLookAt(p.x + 8, p.y + 8, p.z - 8, p.x, p.y, p.z, 0, 1, 0);
              }

              GlrScene sceneAdapter = AdapterFactory.getAdapterFor(sgScene);
              sceneAdapter.setupAffectors(rc);
              gl.glEnable(GL.GL_DEPTH_TEST);

              //todo: support alpha
              //              gl.glDisable( com.jogamp.opengl.GL.GL_BLEND );
              transformableAdapter.EPIC_HACK_FOR_ICON_CAPTURE_renderOpaque(rc);
              //              gl.glEnable( com.jogamp.opengl.GL.GL_BLEND );
              //              gl.glBlendFunc( com.jogamp.opengl.GL.GL_SRC_ALPHA, com.jogamp.opengl.GL.GL_ONE_MINUS_SRC_ALPHA );
              //              transformableAdapter.renderAlphaBlended( rc );
              //              gl.glDisable( com.jogamp.opengl.GL.GL_BLEND );
              gl.glDisable(GL.GL_DEPTH_TEST);
            }
          }, viewport, rImageBuffer, ImageOrientationRequirement.RIGHT_SIDE_UP_REQUIRED, new ImageCaptureObserver() {
            @Override
            public void done(ImageBuffer result) {
              imageIcon = new ImageIcon(result.getImage());
              repaintComponentsIfNecessary();
              //edu.cmu.cs.dennisc.java.util.logging.Logger.severe( result );
            }
          });
        }
      }
    }
    return this.imageIcon;
  }

  private final UserField field;
  private final Icon fallbackIcon;
  private ImageIcon imageIcon;
  private boolean isStarted;
}
