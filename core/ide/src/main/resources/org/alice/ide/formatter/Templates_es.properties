AbstractValueLiteral = </value/>
Argument = </getParameterNameText()/> </expression/>
ArrayAccess = </array/> [ </index/> ]
ArrayInstanceCreation = nuevo </arrayType/> { </expressions/> }
ArrayLength = </array/>.distancia
AssignmentExpression = </leftHandSide/> </_gets_toward_leading_/> </rightHandSide/>
BooleanExpressionBodyPair = if </expression/> es verdadero then\n\t</body/>
Comment = // </text/>
CountLoop = contar hasta </count/>\n\t</body/>\n\t ciclo
DoInOrder = hacerlo en orden\n\t</body/>
DoTogether = hacerlo juntos\n\t</body/>
EachInArrayTogether = cada </__item__/> en </array/> juntos\n\t</body/>
FieldAccess = </expression/> </field/>
ForEachInArrayLoop = para cada </__item__/> en </array/>\n\t</body/>\n\t lazo
InfixExpression = </leftOperand/> </operator/> </rightOperand/>
InstanceCreation = nuevo constructor </constructor/> </requiredArguments/></variableArguments/></keyedArguments/>
LambdaExpression = </value/>
LocalAccess = </local/>
LogicalComplement = NEGACION </operand/>
MethodInvocation = </expression/> </method/> </requiredArguments/> </variableArguments/> </keyedArguments/>
NullLiteral = deshacerLosCambiosRecientes
ParameterAccess = </parameter/>
ResourceExpression = </resource/>
ReturnStatement =  </expression/>
StringConcatenation = </leftOperand/> +</rightOperand/>
SuperConstructorInvocationStatement =  </requiredArguments/> </variableArguments/> </keyedArguments/>
ThisConstructorInvocationStatement = este </requiredArguments/></variableArguments/></keyedArguments/>
ThisExpression = este
UserLambda = hacerlo en orden\n\t</body/>
WhileLoop = while </conditional/> es verdadero\n\t</body/>\n\t ciclo
